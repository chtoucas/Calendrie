<#@ assembly name="$(CalendrieT4Assembly)" #>
<#@ include file="Calendar.EmitClock.tt" #>
<#@ include file="Calendar.EmitDate.tt" #>
<#@ include file="Calendar.EmitMonth.tt" #>
<#@ include file="Calendar.EmitYear.tt" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="Calendrie.TextTemplating" #><#+

public partial class CalendarTemplate : CSharpTemplate
{
    public CalendarTemplate(
        TextTransformation parent,
        string schemaClass,
        string epoch,
        string epochDaysSinceZeroValue,
        string maxDaysSinceEpochValue,
        bool regular = true) : base(parent)
    {
        if (String.IsNullOrWhiteSpace(schemaClass))
            throw new ArgumentException("The schema can not be null or blank.", nameof(schemaClass));

        if (String.IsNullOrWhiteSpace(epoch))
            throw new ArgumentException("The epoch can not be null or blank.", nameof(epoch));

        SchemaClass = schemaClass;
        Epoch = epoch;
        EpochDaysSinceZeroValue = epochDaysSinceZeroValue;
        DisplayName = Name;
        Prefix = Name;
        MaxDaysSinceEpochValue = maxDaysSinceEpochValue;

        IsRegular = regular;
    }

    public string SchemaClass { get; }
    public string Epoch { get; }
    public string EpochDaysSinceZeroValue { get; }
    public string ScopeClass { get; set; } = "StandardScope";

    public bool IsRegular { get; }
    public int MonthsInYear { get; set; }

    // NB: we don't check the setter because these are design time templates:
    // if "value" is null or invalid, then the T4 transformation will fail right
    // away.

    public string DisplayName { get; set; }
    public string Prefix { get; set; }

    // PC = Pascal case
    public string DaysSinceEpochPC { get; set; } = "DaysSinceEpoch";
    public string DaysSinceEpochVar { get; set; } = "daysSinceEpoch";
    public string MaxDaysSinceEpoch { get; set; } = "MaxDaysSinceEpoch";
    public string MaxDaysSinceEpochValue { get; }

    // Fake "integer" value therefore, if not set, the T4 output will be invalid.
    public string MaxMonthsSinceEpochValue { get; set; } = "XXX";

    public bool EnableIsIntercalaryDay { get; set; } = true;
    public bool EnableIsSupplementaryDay { get; set; } = true;
    // EnableIsIntercalaryMonth is handled automatically.
    public bool EnableIsLeapYear { get; set; } = true;

    // Depends on the EditorConfig. If CA is enabled on generated files, this
    // is not necessary.
    public bool EnableNullable { get; set; }
    public bool EnablePragmas { get; set; }
    public bool ImportCalendrieSystemsNamespace { get; set; }

    public bool EnableCalendar { get; set; } = true;
    public bool EnableDate { get; set; } = true;
    public bool EnableDateCustomMath { get; set; }
    public bool EnableMonth { get; set; } = true;
    public bool EnableMonthCustomMath { get; set; }
    public bool EnableYear { get; set; } = true;
    public bool EnableClock { get; set; }

    protected sealed override void WriteContent()
    {
        // May be necessary, depends on the Code Analysis settings regarding
        // generated files.
        if (EnableNullable) EmitNullable();
        if (EnablePragmas)  EmitPragmas();

        EmitNamespace();
        EmitUsings();

        if (EnableCalendar) EmitCalendar();
        if (EnableClock)    EmitClock();
        if (EnableDate)     EmitDate();
        if (EnableMonth)    EmitMonth();
        if (EnableYear)     EmitYear();
    } // T4: End of WriteContent()

    protected virtual void EmitNullable()
    {
        WriteLine();
#>
#nullable enable
<#+
    } // T4: End of EmitNullable()

    protected virtual void EmitPragmas()
    {
        WriteLine();
#>
#pragma warning disable IDE0002 // Simplify Member Access (Style) ✓
<#+
    } // T4: End of EmitPragmas()

    protected virtual void EmitNamespace()
    {
        WriteLine();
#>
namespace <#= Namespace #>;
<#+
    } // T4: End of EmitNamespace()

    protected virtual void EmitUsings()
    {
        WriteLine();

        // Assumption: we import globally the following namespaces
        // - System
        // - System.Collections.Generic
        // - System.Diagnostics
        // - System.Diagnostics.CodeAnalysis
        // - System.Diagnostics.Contracts
        // - System.Linq
        // - System.Runtime.CompilerServices
#>
using System.Numerics;

using Calendrie;
<#+ if (EnableMonth) { #>
using Calendrie.Core.Intervals;
<#+ } #>
using Calendrie.Core.Schemas;
using Calendrie.Core.Utilities;
using Calendrie.Hemerology;
<#+ if (EnableClock) { #>
using Calendrie.Horology;
<#+ } #>
<#+ if (ImportCalendrieSystemsNamespace) { #>
using Calendrie.Systems;
<#+ } #>

using static Calendrie.Core.CalendricalConstants;
<#+
    } // T4: End of EmitUsings()

    protected virtual void EmitCalendar()
    {
        // WARNING: the constructors of the schema and the scope MUST have a
        // fixed form as one can see below.

        WriteLine();
#>
#region <#= Prefix #>Calendar
<#+
        EmitCalendarPreamble();

        if (IsRegular)
        {
            EmitCalendarMathRegular();
        }
        else
        {
            EmitCalendarMathNonRegular();
        }
#>

#endregion
<#+
    }

    protected virtual void EmitCalendarPreamble()
    {
        WriteLine();
#>
/// <summary>
/// Represents the <#= DisplayName #> calendar.
/// <para>This calendar is <i>retropolated</i>. It supports <i>all</i> dates
/// within the range [1..9999] of years.</para>
/// <para>This class cannot be inherited.</para>
/// </summary>
public sealed partial class <#= Prefix #>Calendar : Calendar
{
    /// <summary>
    /// Represents the display name.
    /// <para>This field is a constant.</para>
    /// </summary>
    internal const string DisplayName = "<#= DisplayName #>";

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= Prefix #>Calendar"/> class.
    /// </summary>
    public <#= Prefix #>Calendar() : this(new <#= SchemaClass #>()) { }

    private <#= Prefix #>Calendar(<#= SchemaClass #> schema)
        : base(DisplayName, new <#= ScopeClass #>(schema, <#= Epoch #>))
    {
        Schema = schema;
    }

    /// <summary>
    /// Gets a singleton instance of the <see cref="<#= Prefix #>Calendar"/> class.
    /// <para>See <see cref="<#= Prefix #>Date.Calendar"/>.</para>
    /// </summary>
    internal static <#= Prefix #>Calendar Instance { get; } = new();

    /// <summary>
    /// Gets the earliest supported year.
    /// </summary>
    public static int MinYear => <#= ScopeClass #>.MinYear;

    /// <summary>
    /// Gets the latest supported year.
    /// </summary>
    public static int MaxYear => <#= ScopeClass #>.MaxYear;

    /// <summary>
    /// Gets the schema.
    /// </summary>
    internal <#= SchemaClass #> Schema { get; }
}
<#+
    } // T4: End of EmitCalendarPreamble()

    protected virtual void EmitCalendarMathRegular()
    {
        WriteLine();
#>
public partial class <#= Prefix #>Calendar // Math
{
    /// <summary>
    /// Adds the specified number of years to the year part of the specified date,
    /// yielding a new date.
    /// <para>This method may truncate the result to the end of the target month
    /// to ensure that it returns a valid date; see <see cref="AdditionRule.Truncate"/>.
    /// </para>
    /// </summary>
    /// <exception cref="OverflowException">The calculation would overflow the
    /// range of supported dates.</exception>
    [Pure]
    internal <#= Prefix #>Date AddYears(int y, int m, int d, int years)
    {
        var sch = Schema;

        // Exact addition of years to a calendar year.
        int newY = checked(y + years);
        if (newY < <#= ScopeClass #>.MinYear || newY > <#= ScopeClass #>.MaxYear)
            ThrowHelpers.ThrowDateOverflow();

        // NB: AdditionRule.Truncate.
        int newD = Math.Min(d, sch.CountDaysInMonth(newY, m));

        int <#= DaysSinceEpochVar #> = sch.CountDaysSinceEpoch(newY, m, newD);
        return <#= Prefix #>Date.UnsafeCreate(<#= DaysSinceEpochVar #>);
    }

    /// <summary>
    /// Adds the specified number of years to the year part of the specified date
    /// and also returns the roundoff in an output parameter, yielding a new date.
    /// <para><paramref name="roundoff"/> corresponds to the number of days that
    /// were cut off, which is greater than or equal to 0, the latter only
    /// happening when the operation is exact.</para>
    /// </summary>
    /// <returns>The end of the target month when roundoff &gt; 0.</returns>
    /// <exception cref="OverflowException">The operation would overflow the
    /// range of supported dates.</exception>
    [Pure]
    internal <#= Prefix #>Date AddYears(int y, int m, int d, int years, out int roundoff)
    {
        var sch = Schema;

        // Exact addition of years to a calendar year.
        int newY = checked(y + years);
        if (newY < <#= ScopeClass #>.MinYear || newY > <#= ScopeClass #>.MaxYear)
            ThrowHelpers.ThrowDateOverflow();

        int daysInMonth = sch.CountDaysInMonth(newY, m);
        roundoff = Math.Max(0, d - daysInMonth);
        // On retourne le dernier jour du mois si d > daysInMonth.
        int newD = roundoff == 0 ? d : daysInMonth;

        int <#= DaysSinceEpochVar #> = sch.CountDaysSinceEpoch(newY, m, newD);
        return <#= Prefix #>Date.UnsafeCreate(<#= DaysSinceEpochVar #>);
    }

    /// <summary>
    /// Adds the specified number of months to the month part of the specified
    /// date, yielding a new date.
    /// <para>This method may truncate the result to the end of the target month
    /// to ensure that it returns a valid date; see <see cref="AdditionRule.Truncate"/>.
    /// </para>
    /// </summary>
    /// <exception cref="OverflowException">The operation would overflow the
    /// range of supported dates.</exception>
    [Pure]
    internal <#= Prefix #>Date AddMonths(int y, int m, int d, int months)
    {
        // Exact addition of months to a calendar month.
        int newM = 1 + MathZ.Modulo(
            checked(m - 1 + months), <#= SchemaClass #>.MonthsPerYear, out int years);

        return AddYears(y, newM, d, years);
    }

    /// <summary>
    /// Adds the specified number of months to the month part of the specified
    /// date and also returns the roundoff in an output parameter, yielding a
    /// new date.
    /// <para><paramref name="roundoff"/> corresponds to the number of days that
    /// were cut off, which is greater than or equal to 0, the latter only
    /// happening when the operation is exact.</para>
    /// </summary>
    /// <returns>The end of the target month when roundoff &gt; 0.</returns>
    /// <exception cref="OverflowException">The operation would overflow the
    /// range of supported dates.</exception>
    [Pure]
    internal <#= Prefix #>Date AddMonths(int y, int m, int d, int months, out int roundoff)
    {
        // Exact addition of months to a calendar month.
        int newM = 1 + MathZ.Modulo(
            checked(m - 1 + months), <#= SchemaClass #>.MonthsPerYear, out int years);

        return AddYears(y, newM, d, years, out roundoff);
    }
}
<#+
    } // T4: End of EmitCalendarMathRegular()

    protected virtual void EmitCalendarMathNonRegular()
    {
        WriteLine();
#>
public partial class <#= Prefix #>Calendar // Math
{
    [Pure]
    internal <#= Prefix #>Date AddYears(int y, int m, int d, int years)
    {
        var sch = Schema;

        // Exact addition of years to a calendar year.
        int newY = checked(y + years);
        if (newY < <#= ScopeClass #>.MinYear || newY > <#= ScopeClass #>.MaxYear)
            ThrowHelpers.ThrowDateOverflow();

        // NB: AdditionRule.Truncate.
        int newM = Math.Min(m, sch.CountMonthsInYear(newY));
        int newD = Math.Min(d, sch.CountDaysInMonth(newY, m));

        int <#= DaysSinceEpochVar #> = sch.CountDaysSinceEpoch(newY, newM, newD);
        return <#= Prefix #>Date.UnsafeCreate(<#= DaysSinceEpochVar #>);
    }

    [Pure]
    internal <#= Prefix #>Date AddYears(int y, int m, int d, int years, out int roundoff)
    {
        throw new NotImplementedException();
    }

    [Pure]
    internal <#= Prefix #>Date AddMonths(int y, int m, int d, int months)
    {
#if RELEASE
        const int MaxMonthsSinceEpoch = <#= MaxMonthsSinceEpochValue #>;
#else
        Debug.Assert(MaxMonthsSinceEpoch == <#= MaxMonthsSinceEpochValue #>);
#endif

        var sch = Schema;

        // Exact addition of months to a calendar month.
        int monthsSinceEpoch = checked(sch.CountMonthsSinceEpoch(y, m) + months);
        if (unchecked((uint)monthsSinceEpoch) > MaxMonthsSinceEpoch)
            ThrowHelpers.ThrowDateOverflow();

        sch.GetMonthParts(monthsSinceEpoch, out int newY, out int newM);

        // NB: AdditionRule.Truncate.
        int newD = Math.Min(d, sch.CountDaysInMonth(newY, newM));

        int <#= DaysSinceEpochVar #> = sch.CountDaysSinceEpoch(newY, newM, newD);
        return <#= Prefix #>Date.UnsafeCreate(<#= DaysSinceEpochVar #>);
    }

    [Pure]
    internal <#= Prefix #>Date AddMonths(int y, int m, int d, int months, out int roundoff)
    {
        throw new NotImplementedException();
    }
}
<#+
    } // T4: End of EmitCalendarMathNonRegular()

} // T4: End of CalendarTemplate

#>
