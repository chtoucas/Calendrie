<#@ assembly name="$(CalendrieT4Assembly)" #>
<#@ include file="Calendar.EmitAdjuster.tt" #>
<#@ include file="Calendar.EmitClock.tt" #>
<#@ include file="Calendar.EmitDate.tt" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="Calendrie.TextTemplating" #><#+

public partial class CalendarTemplate : CSharpTemplate
{
    public CalendarTemplate(TextTransformation parent, string schemaClass, string epoch) : base(parent)
    {
        if (String.IsNullOrWhiteSpace(schemaClass))
            throw new ArgumentException("The schema can not be null or blank.", nameof(schemaClass));

        if (String.IsNullOrWhiteSpace(epoch))
            throw new ArgumentException("The epoch can not be null or blank.", nameof(epoch));

        SchemaClass = schemaClass;
        Epoch = epoch;
        DisplayName = Name;
        Prefix = Name;
    }

    public string SchemaClass { get; }
    public string Epoch { get; }
    public string ScopeClass { get; set; } = "StandardScope";

    // NB: we don't check the setter because these are design time templates:
    // if "value" is null or invalid, then the T4 transformation will fail right
    // away.

    public string DisplayName { get; set; }
    public string Prefix { get; set; }

    public string DaysSinceEpochField { get; set; } = "_daysSinceEpoch";
    public string DaysSinceEpochVar { get; set; } = "daysSinceEpoch";
    public string DaysSinceEpochStaticSuffix { get; set; } = "DaysSinceEpoch";

    // Temporary property until we decide what to do with clocks.
    public bool EnableClock { get; set; }

    protected sealed override void WriteContent()
    {
        // Apparently, it's no longer necessary.
        //EmitPragmas();

        EmitNamespace();
        EmitUsings();

        EmitScope();
        EmitCalendar();
        EmitAdjuster();

        if (EnableClock)
        {
            EmitClock();
        }

        EmitDate();
    } // T4: End of WriteContent()

    protected virtual void EmitPragmas()
    {
        WriteLine();
#>
#nullable enable
<#+
    } // T4: End of EmitPragmas()

    protected virtual void EmitNamespace()
    {
        WriteLine();
#>
namespace <#= Namespace #>;
<#+
    } // T4: End of EmitNamespace()

    protected virtual void EmitUsings()
    {
        WriteLine();
#>
using Calendrie.Core.Intervals;
using Calendrie.Core.Schemas;
using Calendrie.Core.Validation;
using Calendrie.Hemerology;
<#+ if (EnableClock) { #>
using Calendrie.Horology;
<#+ } #>
<#+
    } // T4: End of EmitUsings()

    protected virtual void EmitScope()
    {
        // WARNING: the constructors of the schema and the scope MUST have a
        // fixed form as one can see below.

        WriteLine();
#>
/// <summary>
/// Provides static methods related to the scope of application of
/// <see cref="<#= Prefix #>Calendar"/>.
/// <para>This class cannot be inherited.</para>
/// </summary>
internal static class <#= Prefix #>Scope
{
    // WARNING: the order in which the static fields are written is __important__.

    public static readonly DayNumber Epoch = <#= Epoch #>;

    // This schema instance is the one used by:
    // - <#= Prefix #>Scope.Instance
    // - <#= Prefix #>Calendar.Instance
    // - All instances of <#= Prefix #>Date
    // - <#= Prefix #>Calendar custom methods only (see the file _Calendar.cs)
    public static readonly <#= SchemaClass #> Schema = new();

    // This scope instance is the one used by:
    // - <#= Prefix #>Calendar.Instance
    // - All instances of <#= Prefix #>Date
    public static readonly <#= ScopeClass #> Instance = new(Schema, Epoch);

    // These properties were only created to ease the initialization of the
    // static fields of <#= Prefix #>Date. Notice that these properties are
    // properties (!) of value type without a backing field, therefore they only
    // exist temporarily.
    public static Range<DayNumber> Domain => Instance.Domain;
    public static int MinDaysSinceEpoch => Instance.Segment.SupportedDays.Min;
    public static int MaxDaysSinceEpoch => Instance.Segment.SupportedDays.Max;

    public static <#= ScopeClass #> Create() => new(new <#= SchemaClass #>(), Epoch);
}
<#+
    } // T4: End of EmitScope()

    protected virtual void EmitCalendar()
    {
        // WARNING: the constructors of the schema and the scope MUST have a
        // fixed form as one can see below.

        WriteLine();
#>
/// <summary>
/// Represents the <#= DisplayName #> calendar.
/// <para>This class cannot be inherited.</para>
/// </summary>
public sealed partial class <#= Prefix #>Calendar : SpecialCalendar<<#= Prefix #>Date>
{
    // This class is not a singleton but we ensure that all date instances are
    // using the same calendar instance. While not mandatory at all, I like the
    // idea.
    internal static readonly <#= Prefix #>Calendar Instance = new(<#= Prefix #>Scope.Instance);

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= Prefix #>Calendar"/> class.
    /// <para>See also <seealso cref="<#= Prefix #>Date.Calendar"/>.</para>
    /// </summary>
    public <#= Prefix #>Calendar() : this(<#= Prefix #>Scope.Create()) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= Prefix #>Calendar"/> class.
    /// </summary>
    private <#= Prefix #>Calendar(<#= ScopeClass #> scope) : base("<#= DisplayName #>", scope)
    {
        Adjuster = new <#= Prefix #>Adjuster(this);
    }

    /// <summary>
    /// Gets the date adjuster.
    /// </summary>
    public <#= Prefix #>Adjuster Adjuster { get; }

    [Pure, MethodImpl(MethodImplOptions.AggressiveInlining)]
    private protected sealed override <#= Prefix #>Date NewDate(int <#= DaysSinceEpochVar #>) => new(<#= DaysSinceEpochVar #>);
}
<#+
    } // T4: End of EmitCalendar()
} // T4: End of CalendarTemplate

#>
